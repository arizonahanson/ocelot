{
package parser

import "github.com/starlight/ocelot/pkg/core"
}

// root of AST
Module ←  expr:Expr EOF {
  return core.List(expr.([]core.Any)), nil
}

// expression list without parentheses
Expr ←  _* first:Any? rest:(_+ Any)* _* {
  return join(first, rest, 1), nil
}

// parent `any` type
Any ←   Atom / Symbol / List

// types that don't eval to another type (contents may)
Atom ←  Number / String / Nil / Bool / Key / Vector / Map

// expression list
List ←  '(' !Atom expr:Expr ')' {
  return core.List(expr.([]core.Any)), nil
} / '(' !Atom Expr !')' {
  return core.Nil{}, errors.New("not terminated")
}

// vector
Vector ←  '[' expr:Expr ']' {
  return core.Vector(expr.([]core.Any)), nil
} / '(' &Atom expr:Expr ')' {
  return core.Vector(expr.([]core.Any)), nil
} / '[' Expr !']' {
  return core.Nil{}, errors.New("not terminated")
} / '(' &Atom Expr !')' {
  return core.Nil{}, errors.New("not terminated")
}

// map
Map ←  '{' _* first:(Key _+ Any)? rest:(_+ Key _+ Any)* _* '}' {
  return core.Map(merge(first, rest, 0, 2)), nil
} / '{' _* (Key _+ Any) (_+ Key _+ Any)* _* !'}' {
  return core.Nil{}, errors.New("not terminated")
}

// literal real number like (-123.45e-67)
Number ←  '-'? digit+ ('.' digit+)? ('e'i '-'? digit+)? {
  return core.String{Val: string(c.text)}.Number()
}

// literal string
String ←  '"' runeChr* '"' {
  return core.String{Val: string(c.text)}.Unquote()
} / '"' runeChr* !'"' {
	return core.Nil{}, errors.New("not terminated")
}
// no bare " or \ inside a String, supports \\, \", \abfnrtv, \xff, \uffff, \Uffffffff
runeChr ←  [^"\\] / runeEsc
runeEsc ←  `\` ([abfnrtv"\\] /
           ('x' hexDigit hexDigit) /
           ('u' hexDigit hexDigit hexDigit hexDigit) /
           ('U' hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit))
hexDigit ← [0-9a-f]i

// nil
Nil ←  "nil" {
  return core.Nil{}, nil
}

// bool
Bool ←  "true" {
  return core.Bool(true), nil
} / "false" {
  return core.Bool(false), nil
}

// identifiers (like ϕa_2)
Symbol ←  word suffix? {
  return core.Symbol{Val: string(c.text), Pos: pos(c.pos)}, nil
}

// key
Key ←  ':' word {
  return core.Key(string(c.text)), nil
}

word ←  letter (letter / digit)*
// suffix
suffix ←  [!?*]
// integer part of Number
digit ←  [0-9]
// unicode letters, and underscore, in indentifiers
letter ←  [\p{L}] / '_'

// UTF-8: whitespace and control chars/unused codes
_ "whitespace" ←  [\p{Z}] / [\p{C}] / Comment

// comments
Comment ←  SingleLineComment / MultiLineComment
SingleLineComment ← "//" (!EOL .)* EOL
MultiLineComment ←  "/*" (!"*/" .)* "*/"

// end of line
EOL ←  '\n' / EOF

// End of file
EOF ←  !.
